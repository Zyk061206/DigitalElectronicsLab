`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2025/01/18 19:06:08
// Design Name: 
// Module Name: eclock
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module eclock(
    input CLK,              // 50MHz时钟
    input mod_adjust,       // 模式切换�???0:正常�???1:调整�???
    input add_min,          // 分钟调整+
    input add_hour,         // 小时调整+
    input rst_n,            // 复位（低有效�???
    output [7:0] an,        // 数码管位�???
    output [7:0] seg        // 数码管段�???
);
    wire CLK_1Hz;
    wire [5:0] sec, min;    // 6位（0-59�???
    wire [4:0] hour;        // 5位（0-23�???
    wire sec_carry, min_carry;

    //实例�???
    Divider100MHz_1Hz divider(
        .CR(rst_n),
        .CLK_100MHz(CLK),
        .CLK_1Hz_Out(CLK_1Hz)
    );

    sec60 esec(
        .rst(rst_n),
        .CLK_1Hz(CLK_1Hz),
        .sec(sec),
        .carry(sec_carry),
        .mod(mod_adjust)
    );

    min60 emin(
        .CLK_1Hz(CLK_1Hz),
        .carryIn(sec_carry),
        .rst(rst_n),
        .mod(mod_adjust),
        .add(add_min),
        .min(min),
        .carry(min_carry)
    );

    hour24 ehour(
        .CLK_1Hz(CLK_1Hz),
        .carryIn(min_carry),
        .rst(rst_n),
        .mod(mod_adjust),
        .add(add_hour),
        .hour(hour)
    );

    
    seg7_driver u_seg7 (
        .clk(CLK),          // 50MHz用于动�?�扫�???
        .sec(sec),
        .min(min),
        .hour(hour),
        .an(an),
        .seg(seg)
    );
endmodule



module seg7_driver (
    input clk,          // 50MHz时钟
    input [5:0] sec,    // 秒（0-59�???
    input [5:0] min,    // 分（0-59�???
    input [4:0] hour,   // 时（0-23�???
    output reg [7:0] an,// 位�?�（低电平有效）
    output reg [7:0] seg // 段�?�（低电平有效，共阴极）
);
    reg [19:0] scan_cnt = 0;       // 扫描计数器（50MHz�???1kHz�???
    reg [2:0] digit_sel = 0;       // 当前扫描位（0-5�???
    reg [3:0] current_digit;       // 当前显示数字
    reg dp_en;                     // 小数点控�???

    // 动�?�扫描（�???1kHz�???
    always @(posedge clk) begin
        scan_cnt <= scan_cnt + 1;
        if (scan_cnt == 20'd50_000) begin
            scan_cnt <= 0;
            digit_sel <= (digit_sel == 3'd5) ? 0 : digit_sel + 1;
        end
    end

    // 位�?�信号生成（示例使用6位数码管�???
    always @(*) begin
        an = 8'b11111111;
        case (digit_sel)
            0: an[0] = 1'b0; // 小时十位
            1: an[1] = 1'b0; // 小时个位
            2: an[2] = 1'b0; // 分隔符（冒号�???
            3: an[3] = 1'b0; // 分钟十位
            4: an[4] = 1'b0; // 分钟个位
            5: an[5] = 1'b0; // 秒十�???
            default : an = 8'b11111111;
            // 可扩展更多位
        endcase
    end

    // 数据选择与段码生�???
    always @(*) begin
        case (digit_sel)
            0: begin current_digit = hour / 10;  dp_en = 0; end  // 小时十位
            1: begin current_digit = hour % 10;  dp_en = 0; end  // 小时个位
            2: begin current_digit = min / 10;   dp_en = 0; end  // 显示"A"作为分隔�???
            3: begin current_digit = min % 10;   dp_en = 0; end  // 分钟十位
            4: begin current_digit = sec / 10;   dp_en = 0; end  // 分钟个位
            5: begin current_digit = sec % 10;   dp_en = 0; end  // 秒十�???
            default: begin current_digit = 4'h0;    dp_en = 0; end
        endcase

        // 段码转换（共阴极�???
        case (current_digit)
    4'h0: seg[6:0] = 7'b1000000; // 0 (a段灭，其他段�???)
    4'h1: seg[6:0] = 7'b1111001; // 1
    4'h2: seg[6:0] = 7'b0100100; // 2
    4'h3: seg[6:0] = 7'b0110000; // 3
    4'h4: seg[6:0] = 7'b0011001; // 4
    4'h5: seg[6:0] = 7'b0010010; // 5
    4'h6: seg[6:0] = 7'b0000010; // 6
    4'h7: seg[6:0] = 7'b1111000; // 7
    4'h8: seg[6:0] = 7'b0000000; // 8
    4'h9: seg[6:0] = 7'b0010000; // 9
    4'hA: seg[6:0] = 7'b1111110; // "-"（仅中间段亮�???
    default: seg[6:0] = 7'b1111111;
        endcase
        seg[7] = ~dp_en; // 小数点控�???
    end
endmodule


module sec60(
    input CLK_1Hz,
    input rst,
    input mod,
    output reg [5:0] sec,
    output reg carry
);
    always @(posedge CLK_1Hz or negedge rst) begin
        if (!rst) begin
            sec   <= 6'd0;
            carry <= 1'b0;
        end
        else if (!mod) begin
            // 如果不在调节模式，可以保持当前状态（或根据需要实现其它逻辑）
            sec   <= sec;
            carry <= 1'b0;
        end
        else begin
            if (sec == 6'd58) begin
                carry <= 1'b1;  // 在计满58后，同步产生进位信号(追回1s误差)
                sec   <= sec + 6'd1;
            end
            else if (sec == 6'd59) begin
                sec   <= 6'd0;
                carry <= 1'b0;
            end
            else begin
                sec   <= sec + 6'd1;
                carry <= 1'b0;
            end
        end
    end
endmodule


module min60 (
    input CLK_1Hz,   // 1Hz时钟
    input rst,       // 异步复位，低有效
    input mod,       // 模式选择，0:正常计时，1:调节
    input add,       // 调节分钟信号（经过消抖、同步）
    input carryIn,   // 来自秒计数的进位信号（在正常模式下使用）
    output reg [5:0] min,
    output reg carry  // 当 min 达到59时产生进位
);
    always @(posedge CLK_1Hz or negedge rst) begin
        if (!rst) begin
            min   <= 6'd0;
            carry <= 1'b0;
        end else if (!mod) begin
            // 调节模式下：检测 add 信号有效时调节分钟
            if (add) begin
                if (min == 6'd59)
                    min <= 6'd0;
                else
                    min <= min + 6'd1;
            end
            // 调节模式下不产生进位
            carry <= 1'b0;
        end else begin
            // 正常计时模式下：仅在收到 carryIn 脉冲时才递增
            if (carryIn) begin
                if (min == 6'd59) begin
                    min   <= 6'd0;
                    carry <= 1'b1;
                end
                else begin
                    min   <= min + 6'd1;
                    carry <= 1'b0;
                end
            end else begin
                carry <= 1'b0;
            end
        end
    end
endmodule


module hour24 (
    input CLK_1Hz,   // 1Hz时钟
    input rst,       // 异步复位，低有效
    input mod,       // 模式选择，0:正常计时，1:调节
    input add,       // 调节小时信号（经过消抖、同步）
    input carryIn,   // 来自分钟计数的进位信号（在正常模式下使用）
    output reg [4:0] hour
);
    always @(posedge CLK_1Hz or negedge rst) begin
        if (!rst) begin
            hour <= 5'd0;
        end 
        else if (!mod) begin
            // 调节模式下：检测 add 信号有效时调节小时
            if (add) begin
                if (hour == 5'd23)
                    hour <= 5'd0;
                else
                    hour <= hour + 5'd1;
            end
        end 
        else begin
            // 正常计时模式下：仅在收到 carryIn 脉冲时才递增
            if (carryIn) begin
                if (hour == 5'd23)
                    hour <= 5'd0;
                else
                    hour <= hour + 5'd1;
            end
        end
    end
endmodule

//!100MHZ
module Divider100MHz_1Hz(
    input  CR,            // 异步复位（低电平有效�??
    input  CLK_100MHz,    // 100MHz时钟输入
    output reg CLK_1Hz_Out  // 1Hz时钟输出
);

    reg [25:0] count_div;       // 26位分频计数器
    parameter CLK_Freq = 100000000; // 输入时钟频率100MHz
    parameter OUT_Freq = 1;          // 输出时钟频率1Hz
    
    always @(posedge CLK_100MHz or negedge CR) begin
        if (!CR) begin              // 复位有效�??
            CLK_1Hz_Out <= 0;
            count_div  <= 0;
        end
        else begin
            if (count_div < (CLK_Freq / (2 * OUT_Freq) - 1)) 
                count_div <= count_div + 1;  // 计数器�?�增
            else begin
                count_div      <= 0;          // 计数器归�??
                CLK_1Hz_Out <= ~CLK_1Hz_Out; // 翻转输出
            end
        end
    end
endmodule

